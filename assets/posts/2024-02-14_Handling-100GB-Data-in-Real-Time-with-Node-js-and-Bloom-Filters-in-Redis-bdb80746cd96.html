<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Handling 100GB Data in Real Time with Node.js and Bloom Filters in Redis</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Handling 100GB Data in Real Time with Node.js and Bloom Filters in Redis</h1>
</header>
<section data-field="subtitle" class="p-summary">
Imagine you’re building a system that analyzes sensor data streaming in at 100GB per hour. Traditional methods might buckle under the…
</section>
<section data-field="body" class="e-content">
<section name="26b6" class="section section--body section--first"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="3da5" id="3da5" class="graf graf--h3 graf--leading graf--title">Handling 100GB Data in Real Time with Node.js and Bloom Filters in Redis</h3><figure name="7a12" id="7a12" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="1*_25Uu6-fkVfSPI5XlI9eHg.jpeg" data-width="1536" data-height="1536" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*_25Uu6-fkVfSPI5XlI9eHg.jpeg"><figcaption class="imageCaption">The Gemini AI-generated image</figcaption></figure><p name="3729" id="3729" class="graf graf--p graf-after--figure">Imagine you’re building a system that analyzes sensor data streaming in at 100GB per hour. Traditional methods might buckle under the pressure, but there’s a hidden gem named <strong class="markup--strong markup--p-strong">Bloom Filters</strong> that can help you process data in real time with surprising efficiency. In this article, we’ll explore how to use Bloom Filters in Redis to tackle this high-load challenge.</p><h4 name="48b8" id="48b8" class="graf graf--h4 graf-after--p"><strong class="markup--strong markup--h4-strong">Why Bloom Filters?</strong></h4><p name="65ee" id="65ee" class="graf graf--p graf-after--h4">Bloom Filters are probabilistic data structures that offer space-efficient membership testing. They use space cleverly, allowing you to check if an item <em class="markup--em markup--p-em">might</em> be present in a dataset without storing the entire dataset itself. This trade-off comes with a small chance of false positives (saying an item is there when it isn’t), but for many high-throughput scenarios, it’s a worthwhile compromise.</p><h4 name="1bf3" id="1bf3" class="graf graf--h4 graf-after--p"><strong class="markup--strong markup--h4-strong">Our Scenario:</strong></h4><p name="51df" id="51df" class="graf graf--p graf-after--h4">Think you have a network of sensors sending real-time readings, generating 100GB of data hourly. You need to identify unique sensor IDs quickly to trigger certain actions. Storing all IDs in memory can be expensive and slow. Bloom Filters to the rescue!</p><h4 name="1433" id="1433" class="graf graf--h4 graf-after--p"><strong class="markup--strong markup--h4-strong">Using RedisBloom:</strong></h4><p name="7788" id="7788" class="graf graf--p graf-after--h4"><a href="https://redis.io/docs/data-types/probabilistic/bloom-filter/" data-href="https://redis.io/docs/data-types/probabilistic/bloom-filter/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">RedisBloom</a> is an extension that adds Bloom Filter functionality to Redis, a popular in-memory data store. Here’s how we can use it:</p><ol class="postList"><li name="36d2" id="36d2" class="graf graf--li graf-after--p">Install and start the Redis database via docker:</li></ol><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="bash" name="a342" id="a342" class="graf graf--pre graf-after--li graf--preV2"><span class="pre--content">docker run -p 6379:6379 -it --<span class="hljs-built_in">rm</span> redis/redis-stack-server:latest</span></pre><p name="4224" id="4224" class="graf graf--p graf-after--pre">2. Establish a connection to your Redis server, using <a href="https://github.com/redis/node-redis" data-href="https://github.com/redis/node-redis" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">node-redis</a> npm package, and create a Bloom Filter named <code class="markup--code markup--p-code">sensor_ids</code> with a capacity suitable for your expected number of unique IDs.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="javascript" name="6884" id="6884" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">import</span> { createClient } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redis&#x27;</span>;<br /><br /><span class="hljs-keyword">const</span> client = <span class="hljs-title function_">createClient</span>();<br /><br /><span class="hljs-keyword">await</span> client.<span class="hljs-title function_">connect</span>();<br /><br /><span class="hljs-keyword">const</span> bloomFilterName = <span class="hljs-string">&#x27;sensor_ids&#x27;</span>;<br /><span class="hljs-keyword">const</span> filterCapacity = <span class="hljs-number">1000000000</span>; <span class="hljs-comment">// 1 billion</span><br /><br /><span class="hljs-keyword">await</span> client.<span class="hljs-property">bf</span>.<span class="hljs-title function_">reserve</span>(bloomFilterName, <span class="hljs-number">0.01</span>, filterCapacity);</span></pre><p name="b42c" id="b42c" class="graf graf--p graf-after--pre">3. As sensor data arrives, efficiently add each unique ID to the Bloom Filter using the <code class="markup--code markup--p-code">bf.add</code> command. For large datasets, consider batching or splitting into smaller chunks. In this case, we simulate a big-sized file that includes 1 billion rows. The capacity is very important for the accuracy of your result. The bigger the capacity the more your filter takes place in memory but the better results he shows.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="javascript" name="0ea6" id="0ea6" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">let</span> promisesArr = [];<br /><br /><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; filterCapacity; i++) {<br />    promisesArr.<span class="hljs-title function_">push</span>(client.<span class="hljs-property">bf</span>.<span class="hljs-title function_">add</span>(bloomFilterName, <span class="hljs-string">&#x27;id&#x27;</span> + i));<br />    <span class="hljs-keyword">if</span> (i % <span class="hljs-number">100000</span> === <span class="hljs-number">0</span>) {<br />        <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(promisesArr);<br />        promisesArr = [];<br />    }<br />    <br />}</span></pre><p name="f81d" id="f81d" class="graf graf--p graf-after--pre">4. When you need to verify if a new ID is unique, use the <code class="markup--code markup--p-code">bf.exists</code> command. It returns a true or false: if it&#39;s false, the ID is likely unique; if true, it might already exist.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="javascript" name="f242" id="f242" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">const</span> existValue = <span class="hljs-string">&#x27;id1&#x27;</span>;<br /><span class="hljs-keyword">const</span> notExistValue = <span class="hljs-string">&#x27;id1000000001&#x27;</span>;<br /><span class="hljs-keyword">const</span> isExists = <span class="hljs-keyword">await</span> client.<span class="hljs-property">bf</span>.<span class="hljs-title function_">exists</span>(bloomFilterName, existValue);<br /><span class="hljs-keyword">const</span> notExists = <span class="hljs-keyword">await</span> client.<span class="hljs-property">bf</span>.<span class="hljs-title function_">exists</span>(bloomFilterName, notExistValue);</span></pre><p name="604a" id="604a" class="graf graf--p graf-after--pre">5. Keep an eye on your Bloom Filter’s size and false positive rate using the <code class="markup--code markup--p-code">bf.info</code> command. You might need to adjust its parameters or consider alternative approaches for extremely large datasets.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="javascript" name="3975" id="3975" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">const</span> info = <span class="hljs-keyword">await</span> client.<span class="hljs-property">bf</span>.<span class="hljs-title function_">info</span>(bloomFilterName);<br /><span class="hljs-comment">// info looks like this:</span><br /><span class="hljs-comment">//</span><br /><span class="hljs-comment">//  {</span><br /><span class="hljs-comment">//    capacity: 1000,</span><br /><span class="hljs-comment">//    size: 1531,</span><br /><span class="hljs-comment">//    numberOfFilters: 1,</span><br /><span class="hljs-comment">//    numberOfInsertedItems: 12,</span><br /><span class="hljs-comment">//    expansionRate: 2</span><br /><span class="hljs-comment">//  }</span></span></pre><h4 name="b9d6" id="b9d6" class="graf graf--h4 graf-after--pre"><strong class="markup--strong markup--h4-strong">Remember:</strong></h4><ul class="postList"><li name="bd45" id="bd45" class="graf graf--li graf-after--h4">Bloom Filters offer a trade-off: space efficiency for occasional false positives. Evaluate if this suits your tolerance for inaccuracies.</li><li name="67ce" id="67ce" class="graf graf--li graf-after--li">Consider alternative approaches (e.g., partitioned Bloom Filters) for extremely large datasets or stricter accuracy requirements.</li></ul><p name="653d" id="653d" class="graf graf--p graf-after--li">The full source code:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="javascript" name="ce6c" id="ce6c" class="graf graf--pre graf-after--p graf--trailing graf--preV2"><span class="pre--content"><span class="hljs-comment">// run redis db</span><br /><span class="hljs-comment">//docker run -p 6379:6379 -it --rm redis/redis-stack-server:latest</span><br /><br /><span class="hljs-keyword">import</span> { createClient } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redis&#x27;</span>;<br /><br /><span class="hljs-keyword">const</span> client = <span class="hljs-title function_">createClient</span>();<br /><br /><span class="hljs-keyword">await</span> client.<span class="hljs-title function_">connect</span>();<br /><br /><span class="hljs-keyword">const</span> bloomFilterName = <span class="hljs-string">&#x27;sensor_ids&#x27;</span>;<br /><span class="hljs-keyword">const</span> filterCapacity = <span class="hljs-number">1000000000</span>; <span class="hljs-comment">// 1 billion</span><br /><span class="hljs-comment">// Delete any pre-existing Bloom Filter.</span><br /><span class="hljs-keyword">await</span> client.<span class="hljs-title function_">del</span>(bloomFilterName);<br /><br /><span class="hljs-keyword">try</span> {<br />    <span class="hljs-keyword">await</span> client.<span class="hljs-property">bf</span>.<span class="hljs-title function_">reserve</span>(bloomFilterName, <span class="hljs-number">0.01</span>, filterCapacity);<br />    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Reserved Bloom Filter.&#x27;</span>);<br />} <span class="hljs-keyword">catch</span> (e) {<br />    <span class="hljs-keyword">if</span> (e.<span class="hljs-property">message</span>.<span class="hljs-title function_">endsWith</span>(<span class="hljs-string">&#x27;item exists&#x27;</span>)) {<br />        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Bloom Filter already reserved.&#x27;</span>);<br />    } <span class="hljs-keyword">else</span> {<br />        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Error, maybe RedisBloom is not installed?:&#x27;</span>);<br />        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e);<br />    }<br />}<br /><br /><span class="hljs-keyword">let</span> promisesArr = [];<br /><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; filterCapacity; i++) {<br />    promisesArr.<span class="hljs-title function_">push</span>(client.<span class="hljs-property">bf</span>.<span class="hljs-title function_">add</span>(bloomFilterName, <span class="hljs-string">&#x27;item&#x27;</span>+i));<br />    <span class="hljs-keyword">if</span> (i % <span class="hljs-number">100000</span> === <span class="hljs-number">0</span>) {<br />        <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(promisesArr);<br />        promisesArr = [];<br />    }<br />    <span class="hljs-keyword">if</span> (i % <span class="hljs-number">10000000</span> === <span class="hljs-number">0</span>) {<br />        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Added 10 million members to Bloom Filter.&#x27;</span>, i);<br />    }<br />}<br /><br /><span class="hljs-keyword">const</span> existValue = <span class="hljs-string">&#x27;item1&#x27;</span>;<br /><span class="hljs-keyword">const</span> notExistValue = <span class="hljs-string">&#x27;item1000000001&#x27;</span>;<br /><span class="hljs-keyword">const</span> simonExists = <span class="hljs-keyword">await</span> client.<span class="hljs-property">bf</span>.<span class="hljs-title function_">exists</span>(bloomFilterName, existValue);<br /><span class="hljs-keyword">const</span> notExists = <span class="hljs-keyword">await</span> client.<span class="hljs-property">bf</span>.<span class="hljs-title function_">exists</span>(bloomFilterName, notExistValue);<br /><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">${existValue}</span> <span class="hljs-subst">${simonExists ? <span class="hljs-string">&#x27;may&#x27;</span> : <span class="hljs-string">&#x27;NOT&#x27;</span>}</span> exist`</span>);<br /><br /><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">${notExistValue}</span> <span class="hljs-subst">${notExists ? <span class="hljs-string">&#x27;may&#x27;</span> : <span class="hljs-string">&#x27;NOT&#x27;</span>}</span> exist`</span>);<br /><br /><span class="hljs-keyword">const</span> info = <span class="hljs-keyword">await</span> client.<span class="hljs-property">bf</span>.<span class="hljs-title function_">info</span>(bloomFilterName);<br /><span class="hljs-comment">// info looks like this:</span><br /><span class="hljs-comment">//</span><br /><span class="hljs-comment">//  {</span><br /><span class="hljs-comment">//    capacity: 1000,</span><br /><span class="hljs-comment">//    size: 1531,</span><br /><span class="hljs-comment">//    numberOfFilters: 1,</span><br /><span class="hljs-comment">//    numberOfInsertedItems: 12,</span><br /><span class="hljs-comment">//    expansionRate: 2</span><br /><span class="hljs-comment">//  }</span><br /><span class="hljs-keyword">await</span> client.<span class="hljs-title function_">quit</span>();</span></pre></div></div></section><section name="5a4b" class="section section--body section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><p name="940a" id="940a" class="graf graf--p graf--leading">By understanding Bloom Filters and using RedisBloom, you can empower your high-load projects to handle massive data streams efficiently and in real time. And there we have it. You can find the full source code on my <a href="https://github.com/TeslenkoOleg/redis-bloom-filter/blob/main/bloom-filter.js" data-href="https://github.com/TeslenkoOleg/redis-bloom-filter/blob/main/bloom-filter.js" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">GitHub page</a>. I strongly recommend looking at the <a href="https://github.com/redis/node-redis" data-href="https://github.com/redis/node-redis" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">official documentation</a> for additional information.</p><p name="7fe7" id="7fe7" class="graf graf--p graf-after--p">Thank you for reading. If you have any questions you can find me on <a href="https://www.linkedin.com/in/oleh-teslenko-720443161/" data-href="https://www.linkedin.com/in/oleh-teslenko-720443161/" class="markup--anchor markup--p-anchor" rel="noopener ugc nofollow noopener" target="_blank">LinkedIn</a>. Feel free to leave comments. You can also read my previous articles:</p><div name="19fe" id="19fe" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://towardsdev.com/encrypt-decrypt-password-node-js-d8be1ccb42cf" data-href="https://towardsdev.com/encrypt-decrypt-password-node-js-d8be1ccb42cf" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://towardsdev.com/encrypt-decrypt-password-node-js-d8be1ccb42cf"><strong class="markup--strong markup--mixtapeEmbed-strong">Encrypt &amp; decrypt password | Node.js</strong><br><em class="markup--em markup--mixtapeEmbed-em">Safety is one of the most part in development. We always need to think about users personal data.</em>towardsdev.com</a><a href="https://towardsdev.com/encrypt-decrypt-password-node-js-d8be1ccb42cf" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="fc7aefc0c83c4aca8d51ac12891f8e3c" data-thumbnail-img-id="0*LRLsy7nxJXS3J9c8" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*LRLsy7nxJXS3J9c8);"></a></div><div name="46c8" id="46c8" class="graf graf--mixtapeEmbed graf-after--mixtapeEmbed"><a href="https://towardsdev.com/ram-in-node-memory-leak-5cfca356ddcc" data-href="https://towardsdev.com/ram-in-node-memory-leak-5cfca356ddcc" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://towardsdev.com/ram-in-node-memory-leak-5cfca356ddcc"><strong class="markup--strong markup--mixtapeEmbed-strong">Memory Leak in Node.js Apps</strong><br><em class="markup--em markup--mixtapeEmbed-em">This is my experience of detecting memory leaks in Node.js applications. I’m working on a project where the load on the…</em>towardsdev.com</a><a href="https://towardsdev.com/ram-in-node-memory-leak-5cfca356ddcc" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="bf8ff6f6e62fd39ade62f4b466cda884" data-thumbnail-img-id="1*-Nq1fQSPq9aeoWxn4WFbhg.jpeg" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/1*-Nq1fQSPq9aeoWxn4WFbhg.jpeg);"></a></div><div name="e274" id="e274" class="graf graf--mixtapeEmbed graf-after--mixtapeEmbed graf--trailing"><a href="https://levelup.gitconnected.com/angular-google-maps-api-11af43f2fea4" data-href="https://levelup.gitconnected.com/angular-google-maps-api-11af43f2fea4" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://levelup.gitconnected.com/angular-google-maps-api-11af43f2fea4"><strong class="markup--strong markup--mixtapeEmbed-strong">Angular Google Maps API</strong><br><em class="markup--em markup--mixtapeEmbed-em">How to integrate Google Maps API into your Angular application without fear of third-party libraries? Not many Angular…</em>levelup.gitconnected.com</a><a href="https://levelup.gitconnected.com/angular-google-maps-api-11af43f2fea4" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="5a4aa3647f0f71ff1ae733a1d735a9a2" data-thumbnail-img-id="1*QhBbJysgz2D4w_XaUPHaQA.png" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/1*QhBbJysgz2D4w_XaUPHaQA.png);"></a></div></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@teslenkooleg2017" class="p-author h-card">Oleh Teslenko</a> on <a href="https://medium.com/p/bdb80746cd96"><time class="dt-published" datetime="2024-02-14T03:14:34.782Z">February 14, 2024</time></a>.</p><p><a href="https://medium.com/@teslenkooleg2017/handling-100gb-data-in-real-time-with-node-js-and-bloom-filters-in-redis-bdb80746cd96" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on September 8, 2024.</p></footer></article></body></html>